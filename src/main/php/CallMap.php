<?php
/**
 * This file is part of bovigo\callmap.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * @package  bovigo_callmap
 */
namespace bovigo\callmap;
/**
 * CallMap implementation to be mixed into proxies generated by NewInstance.
 */
trait CallMap
{
    /**
     * map of method with closures to call instead
     *
     * @type  array
     */
    private $callMap = [];
    /**
     * @var  array
     */
    private $callHistory = [];
    /**
     * switch whether passing calls to parent class is allowed
     *
     * @type  bool
     */
    private $parentCallsAllowed = true;

    /**
     * disable passing calls to parent class
     *
     * @return  $this
     */
    public function preventParentCalls()
    {
        $this->parentCallsAllowed = false;
        return $this;
    }

    /**
     * sets the call map to use
     *
     * @param   array  $callMap
     * @return  $this
     */
    public function mapCalls(array $callMap)
    {
        $this->callMap = $callMap;
        return $this;
    }

    /**
     * handles actual method calls
     *
     * @param   string   $method
     * @param   mixed[]  $arguments
     * @return  mixed
     */
    protected function handleMethodCall($method, $arguments)
    {
        $invokationCount = $this->recordCall($method, $arguments);
        if (isset($this->callMap[$method])) {
            if (is_callable($this->callMap[$method])) {
                return call_user_func_array($this->callMap[$method], $arguments);
            } elseif ($this->callMap[$method] instanceof InvocationResults) {
                return $this->callMap[$method]->valueForInvocation($invokationCount - 1);
            }

            return $this->callMap[$method];
        }

        if ($this->parentCallsAllowed && is_callable(['parent', $method])) {
            // is_callable() returns true even for abstract methods
            $refMethod = new \ReflectionMethod(get_parent_class(), $method);
            if (!$refMethod->isAbstract()) {
                return call_user_func_array(['parent', $method], $arguments);
            }
        }

        return null;
    }

    /**
     * records method call for given method
     *
     * @param   string  $method
     * @return  int  amount of calls for given record
     */
    private function recordCall($method, $arguments)
    {
        if (!isset($this->callHistory[$method])) {
            $this->callHistory[$method] = [];
        }

        $this->callHistory[$method][] = $arguments;
        return count($this->callHistory[$method]);
    }

    /**
     * returns amount of calls received for given method
     *
     * @param   string  $method  name of method to check
     * @return  int
     */
    public function callsReceivedFor($method)
    {
        if (isset($this->callHistory[$method])) {
            return count($this->callHistory[$method]);
        }

        return 0;
    }

    /**
     * returns the arguments received for a specific call
     *
     * @param   string  $method      name of method to check
     * @param   int     $invocation  nth invocation to check, defaults to 1 aka first invocation
     * @return  mixed[]
     */
    public function argumentsReceived($method, $invocation = 1)
    {
        if (isset($this->callHistory[$method]) && isset($this->callHistory[$method][$invocation - 1])) {
            return $this->callHistory[$method][$invocation - 1];
        }

        return null;
    }
}
